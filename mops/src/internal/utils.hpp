#ifndef MOPS_UTILS_HPP
#define MOPS_UTILS_HPP

#include <cstddef>
#include <cstdint>
#include <vector>

#include "mops/tensor.hpp"

/// Given an index-add-like index tensor, which contains the positions in the output tensor
/// at which every element of the index tensor will be summed, return a vector of vectors
/// which, for each output position, contains the indices of the elements of the index tensor
/// that wrote (or will write) to it.
std::vector<std::vector<size_t>> get_write_list(mops::Tensor<int32_t, 1> write_coordinates);

/// Find the number of elements in a 256-bit SIMD register for a given type.
template <typename scalar_t> constexpr size_t get_simd_element_count();
// Assume 256-bit vector registers. A conservative choice.
// On HPE, 512 seems to provide an extra 50% boost on one core.
template <> constexpr size_t get_simd_element_count<double>() {
    return 256 / (sizeof(double) * 8); // 256 bits / 64 bits
}
template <> constexpr size_t get_simd_element_count<float>() {
    return 256 / (sizeof(float) * 8); // 256 bits / 32 bits
}

/// Given a two-dimensional tensor, interleave some of the elements of the first dimension
/// into a third dimension, and store the remaining elements in a separate array.
/// The input tensor is assumed to have a shape of (batch_dim, calculation_dim), and
/// simd_element_count is the number of elements to interleave.
/// Then, the interleft_data will have a shape of (batch_dim // simd_element_count, calculation_dim,
/// simd_element_count), and the remainder_data will have a shape of (calculation_dim, batch_dim %
/// simd_element_count).
template <typename scalar_t, size_t simd_element_count>
void interleave_tensor(
    mops::Tensor<scalar_t, 2> initial_data, scalar_t* interleft_data, scalar_t* remainder_data
) {

    size_t batch_dim = initial_data.shape[0];
    size_t remainder = batch_dim % simd_element_count;
    size_t quotient = batch_dim / simd_element_count;
    size_t calculation_dim = initial_data.shape[1];
    scalar_t* initial_data_ptr = initial_data.data;

#pragma omp parallel for
    for (size_t i = 0; i < quotient; i++) {
        for (size_t j = 0; j < calculation_dim; j++) {
            for (size_t k = 0; k < simd_element_count; k++) {
                interleft_data[i * calculation_dim * simd_element_count + j * simd_element_count + k] =
                    initial_data_ptr[i * simd_element_count * calculation_dim + k * calculation_dim + j];
            }
        }
    }

    for (size_t j = 0; j < calculation_dim; j++) {
        for (size_t k = 0; k < remainder; k++) {
            remainder_data[j * remainder + k] = initial_data_ptr
                [quotient * simd_element_count * calculation_dim + k * calculation_dim + j];
        }
    }
}

/// Given interleft_data and remainder_data, in the format generated by interleave_tensor,
/// un-interleave the elements into a two-dimensional tensor (output_data).
/// This is the inverse operation of interleave_tensor.
template <typename scalar_t, size_t simd_element_count>
void un_interleave_tensor(
    mops::Tensor<scalar_t, 2> output_data, scalar_t* interleft_data, scalar_t* remainder_data
) {

    size_t batch_dim = output_data.shape[0];
    size_t remainder = batch_dim % simd_element_count;
    size_t quotient = batch_dim / simd_element_count;
    size_t calculation_dim = output_data.shape[1];
    scalar_t* output_data_ptr = output_data.data;

#pragma omp parallel for
    for (size_t i = 0; i < quotient; i++) {
        for (size_t j = 0; j < calculation_dim; j++) {
            for (size_t k = 0; k < simd_element_count; k++) {
                output_data_ptr[i * simd_element_count * calculation_dim + k * calculation_dim + j] =
                    interleft_data[i * calculation_dim * simd_element_count + j * simd_element_count + k];
            }
        }
    }

    // Fill remainder_data
    for (size_t j = 0; j < calculation_dim; j++) {
        for (size_t k = 0; k < remainder; k++) {
            output_data_ptr[quotient * simd_element_count * calculation_dim + k * calculation_dim + j] =
                remainder_data[j * remainder + k];
        }
    }
}

#endif
